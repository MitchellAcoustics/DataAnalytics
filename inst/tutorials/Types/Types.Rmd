---
title: "Types"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(dplyr)
knitr::opts_chunk$set(echo = FALSE)
```


## Introduction

In the previous tutorials, we jump right into working with data and glossed over a lot of the details. In this tutorial, we take a step back to consider what happens when we load data in memory: how does R represents that data internally and what that means for what we can do with it. We will also talk about how we can change the way R represents a specific piece of data so we can make what we want with it, be it a plot, a table, or a model.

This tutorial draws heavily on [R for data science](https://r4ds.hadley.nz/transform) chapter 12 to 18. I highly recommend you refer to these chapters for more detailed explanation of any of the topics covered below.

Let's jump in and talk about data structures. In order to manipulate data, programming languages use a number of data structures. They do not all have the same data structures and this can make it awkward when you code in more than one language. In R, the main data structures are vectors, lists, matrices, and data frames. We will cover each of these in turn. 
While we talk about data structures, we will also talk about types, types describe how data is stored in memory and what operations can be performed on it. In R, the main types are logical, integer, double, character, and factor. We will cover these at the same time we cover data structure. A useful reference for an in-depth presentation of both is the [Advanced R book](https://adv-r.hadley.nz/) (specifically chapter 3 Vectors).
Before we jump in, let's just note that R does not have a data structure for scalars, a single number, in R a scalar is just a vector of length 1.

## Vectors

A vector is a uni-dimensional data structure. It can contain elements of the same type. The most common types of vectors are logical, numeric, and character vectors.

```{r, echo=TRUE}
v <- c(1:5)
v

is.vector(v)
```


### Logical vectors

A logical vector is a vector that can only contains three values: TRUE, FALSE, and NA (missing value).

```{r, echo=TRUE}
v <- c(TRUE, FALSE, TRUE, NA)
v

is.vector(v)
```

Very often logical vectors are used as a result of some operation on data and can be very useful to subset data.

In the example below, use mutate to create the auth variable which checks whether a respondent scored above 3 on the libertarian to authoritarian scale (libauth variable).

```{r logvec, exercise=TRUE}
bsa <- readRDS("data/bsa2021_healthcare_equalities_recoded.rds")

bsa <- ____ |> ____(auth = ____ >= ____)

summary(bsa$auth)

```

```{r logvec-solution}
bsa <- readRDS("data/bsa2021_healthcare_equalities_recoded.rds")

bsa <- bsa |> mutate(auth = libauth >= 3)

summary(bsa$auth)

```

One of the great things you can do with logical vectors is use them to do Boolean algebra using the `&` (and), `|` (or), and `!` (not) operators.

Another operator that is useful and generate logical vectors as a result is the `%in%` operator. This operator checks whether the elements of the first vector are in the second vector. Use `%in%` in the code below to see how it works:

```{r in, exercise=TRUE}
1:12 ____ c(1, 3, 5, 7, 9, 11)


```


### Thing you should know about vectors

Vectors can only contain elements of the same type. If you try to create a vector with elements of different types, R will coerce them to the same type. So if you try to create a vector with a number and a character, R will coerce the number to a character.
Use the `str()` function to check the type of the elements in the vector v below:

```{r vecchar, exercise=TRUE}
v <- c(1, "a", 2, 4)



```


## Numbers

R does not have scalars so uses vector of length 1 instead to represent single numbers.
Use the `is.vector()`, `mode()`, and `typeof()` functions to check the type of the variable v below:

```{r scalar, exercise=TRUE}}
v <- 1

```


## Strings

## Regular expressions

## Factors

## Dates and times

## Missing value


