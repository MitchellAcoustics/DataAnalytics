---
title: "Data structures and types"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(dplyr)
knitr::opts_chunk$set(echo = FALSE)
```


## Introduction

In the previous tutorials, we jump right into working with data and glossed over a lot of the details. In this tutorial, we take a step back to consider what happens when we load data in memory: how does R represents that data internally and what that means for what we can do with it. We will also talk about how we can change the way R represents a specific piece of data so we can make what we want with it, be it a plot, a table, or a model.

This tutorial draws heavily on [R for data science](https://r4ds.hadley.nz/transform) chapter 12 to 18. I highly recommend you refer to these chapters for more detailed explanation of any of the topics covered below.

Let's jump in and talk about data structures. In order to manipulate data, programming languages use a number of data structures. They do not all have the same data structures and this can make it awkward when you code in more than one language. In R, the main data structures are vectors, lists, matrices, and data frames. We will cover each of these in turn. 
While we talk about data structures, we will also talk about types, types describe how data is stored in memory and what operations can be performed on it. In R, the main types are logical, integer, double, character, and factor. We will cover these at the same time we cover data structure. A useful reference for an in-depth presentation of both is the [Advanced R book](https://adv-r.hadley.nz/) (specifically chapter 3 Vectors).
Before we jump in, let's just note that R does not have a data structure for scalars, a single number, in R a scalar is just a vector of length 1.

## Vectors

A vector is a uni-dimensional data structure. It can contain elements of the same type. The most common types of vectors are logical, numeric, and character vectors.

```{r, echo=TRUE}
v <- c(1:5)
v

is.vector(v)
```


### Logical vectors

A logical vector is a vector that can only contains three values: TRUE, FALSE, and NA (missing value).

```{r, echo=TRUE}
v <- c(TRUE, FALSE, TRUE, NA)
v

is.vector(v)
```

Very often logical vectors are used as a result of some operation on data and can be very useful to subset data.

In the example below, use mutate to create the auth variable which checks whether a respondent scored above 3 on the libertarian to authoritarian scale (libauth variable).

```{r logvec, exercise=TRUE}
bsa <- readRDS("data/bsa2021_healthcare_equalities_recoded.rds")

bsa <- ____ |> ____(auth = ____ >= ____)

summary(bsa$auth)

```

```{r logvec-solution}
bsa <- readRDS("data/bsa2021_healthcare_equalities_recoded.rds")

bsa <- bsa |> mutate(auth = libauth >= 3)

summary(bsa$auth)

```

One of the great things you can do with logical vectors is use them to do Boolean algebra using the `&` (and), `|` (or), and `!` (not) operators.

Another operator that is useful and generate logical vectors as a result is the `%in%` operator. This operator checks whether the elements of the first vector are in the second vector. Use `%in%` in the code below to see how it works:

```{r in, exercise=TRUE}
1:12 ____ c(1, 3, 5, 7, 9, 11)


```


### Thing you should know about vectors

Vectors can only contain elements of the same type. If you try to create a vector with elements of different types, R will coerce them to the same type. So if you try to create a vector with a number and a character, R will coerce the number to a character.
Use the `str()` function to check the type of the elements in the vector v below:

```{r vecchar, exercise=TRUE}
v <- c(1, "a", 2, 4)



```


## Numbers

R does not have scalars so uses vector of length 1 instead to represent single numbers.
Use the `is.vector()`, `mode()`, and `typeof()` functions to check the type of the variable v below:

```{r scalar, exercise=TRUE}
v <- 1

```



## Matrices

Matrices are two dimensional arrays.
Type the name of the matrix and run the code to see it.

```{r mat, exercise=TRUE}
matrix <- matrix(data = c(1:6), nrow = 2, byrow = TRUE)

____

```

### Types

Matrix and vectors can only hold data of one type.
If you try to create a vector or matrix with data of different type, it will be of the type that allows to represent all elements of the matrix.
Look at the matrices below to see what type they are. You can type their name to see how they are displayed, and also use the function `typeof()` to see their type.

```{r mattype, exercise=TRUE}
matrix1 <- matrix(data = c(1:6), nrow = 2, byrow = TRUE)
matrix2 <- matrix(data = c(1, 2, 3, 4, 5, 3.14), nrow = 2, 
                  byrow = TRUE)
matrix3 <- matrix(data = c(1:5, "Marmalade"), nrow = 2, byrow = TRUE)

____

```


## Data frame

Data frames are two dimensional arrays (like matrices) but they can hold various types of data.
Display the data frame below to see what it looks like.

```{r df, exercise=TRUE}
dt <- data.frame(name = c("Julia", "Simon", "Christina"), 
                 age = c(24, 26, 19), 
                 sex = c("Female", "Male", "Female"))

____

```

```{r df-solution}
dt <- data.frame(name = c("Julia", "Simon", "Christina"), 
                 age = c(24, 26, 19), 
                 sex = c("Female", "Male", "Female"))

dt

```

Within each column, every element has to have the same type.

There are two important function that are useful with data frames (and other types):
`summary` and `str`, use them below.

```{r df2, exercise=TRUE, exercise.setup="df-solution"}

____(dt)

____(dt)

```

Internally, data frames are lists of vectors. This means that you can access the columns of a data frame using the `$` operator or the `[[` operator. Try accessing the age column of the dt data frame below:

```{r df3, exercise=TRUE, exercise.setup="df-solution"}

____$____

____[["____"]]

```

## Lists

Lists are very useful because of their flexibility, but this also makes them sometimes difficult to work with.

Elements of a lists can be of any type (even list). Data frames are also lists under the hood, but with limitations on their structure (no two column can have the same name, the length of every column needs to be the same).
Run the code to create the list below, then play around with the elements to display only some of them. You can access the elements of a list in two ways: using `[[]]` and `[]`, which do not produce the same result. Play around with these as well. I suggest you use the `str()` and `typeof()` functions on the output of your subsetting to see how the results differ.

```{r list, exercise=TRUE}
l <- list(c(1:3), "Today", matrix(1:6, nrow = 2))

l____
l____
```


We have now covered the basics data structures that you are likely to encounter in the course of doing data analysis. We will now switch to looking at some of the data types that


## Strings

## Regular expressions

## Factors

## Dates and times

## Missing value

R codes missing values as `NA`

It also has codes for not-a-number: `NaN`

And `NULL`

Think carefully about these when you are using/writing functions as they might not all evaluate to the same result.


## Packages

Much of R strength rely on the ecosystem of packages that it comes with.

In many languages, library is the term used to describe what an R package is (confusingly, you load a package in memory using the function `library()`).

What is a package? 

It is a collection of functions that allow you to perform specific types of operations, usually because they are not available among the functions the software comes prepackaged with.

R has packages for tasks like data loading, data wrangling, visualisation, modelling and many more tasks.

## Installing packages

Packages are installed with the function `install.packages()` and updated with `update.packages()`

```{r, eval = FALSE}
install.packages("name of the package")
install.packages(c("package_1", "package_2"))

```

Once you have installed a package, you need to load it before you can use the functions in it.

```{r, eval = FALSE}
library(name_of_the_package)

# What most people do (me included) 
function_from_package(args)

# What you should do in your scripts
# This is safe if two packages have a function with the same name
name_of_the_package::function_from_package(args)
```

