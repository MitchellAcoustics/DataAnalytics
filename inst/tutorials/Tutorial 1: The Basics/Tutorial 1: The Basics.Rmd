---
title: "Tutorial"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(nycflights13)
library(dplyr)
knitr::opts_chunk$set(echo = FALSE)
```

## Tutorial 1: the basics

This tutorial has three parts, all based on a different chapter of R for data science (https://r4ds.hadley.nz/).

- The basics (chapter 2)
- data transformation (chapter 3)
- data import (chapter 7)


## The basics

This first part of the tutorial walks you through the bases of programming in R, it roughly follows the second chapter of R for data science.


### R is a calculator 

Write the R code required to add fifty-nine plus seventy-three plus two, divided by three:

```{r basicOperations, exercise=TRUE}

```

### Creating objects

You can use the `<-` (assignment operator) to create an object. You can then use code to manipulate objects.
Assign the value 2 to an object called two:

```{r objects, exercise=TRUE}
#Example
one <- 1

one

two

```


### the `c()` function

The `c()` function allows you to create vectors containing several elements.
You can do operations on the resulting vector. Try it:

```{r c, exercise=TRUE}
#Example
number <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)

number

#Try an operation here:

```


### Comments

Code is not always straightforward and there are plenty of time (what I mean here is: ALL THE TIME) when an additional comment might make it easier for the reader of your code to understand what you were trying to achieve.

```{r comment, exercise=TRUE}
#This is a comment, they all start with #

# Write an operation and a comment explaining what it does:

```


### Functions

Functions are pre-written code to perform specific operations. Many are built-in R, and many more can be access through installing additional packages. 
Functions is how we do most things in R. 
For example, you can use the `sum()` function to add a large number of numbers, for example, numbers that you have stored in a vector


```{r functions, exercise=TRUE}
# This is a vector of 10,000 numbers between 1 and 100
numb <- sample(1:100, 10000, replace = TRUE)


```

You could then do further modifications on the results, for example divide by the number of items in your vector to get the average (you can do this with the `length()` function). Note that there is a built-in function for the average: `mean()`

## Data transformation

This part of the tutorial is roughly based on chapter 3 of R for data science. 
For a lot of the day to day data wrangling, we will use the package `dplyr`.
Like in chapter 3 of R for data science, I use the `nycflights13` package to access data on flights from New York in 2013.

First, let's look at the data.

```{r flights}
library(nycflights13)
flights


```

`dplyr` provides tools to manipulate data frame and perform many of the common data wrangling tasks that will be performed during data analysis.

We will start with operations on rows, then move on to operations on columns.

### Filter: Flights on the first of January

The code below filters the dataframe for flights on the first of January. 
Can you add code to check the number of flights that left New York on the 1st of January 2013?

```{r firstjan, exercise=TRUE}
filter(flights, day == 1 & month == 1)


```

The first argument is always a dataframe, and the output is also a dataframe.

### Distinct: Counting unique occurences

The `disctinct()` function will help find all the unique rows. 
It is specifically useful to find unique combinations of variables, for example, below, use distinct to find all the unique pairs of airports in the datasets (use the variables `origin` and `dest`):

```{r occ, exercise=TRUE}
distinct(flights, ____, ____)


```



```{r quiz}
quiz(
  question("How many unique pairs of airports are there in this dataset?",
    answer("25"),
    answer("214"),
    answer("224", correct = TRUE),
    answer("236")
  )
)
```

### Count: how many flights to a specific destination

If you want to calculate how many flights there were between two destinations, you can use the `count()` function.
Try it below. Once you have done that, you can also use an additional argument in the function, `sort`, in order to sort the result. Sort takes only the value TRUE or FALSE.

```{r count, exercise=TRUE}
count(flights, ____, ____)


```

We now move on to functions that allow you to do operations on columns.

### Mutate: the workhorse of data wrangling

The function `mutate()` allows you to compute new variables for your dataset.
For example, in the `flights` data, you can compute the speed of the aircraft during a specific flight by using the `distance` and the `air_time` variables, keep in mind that air_time is in minutes.

```{r mut, exercise=TRUE}
mutate(flights, speed = )

```

```{r mut-hint}
mutate(flights, speed = ____ / ____)

```

### Select: retain only the columns you need

The function `select` allows you to only retain the columns you need for the computation at hand.

Use the `flights` dataset to select the columns: year, month, and day. 

```{r select, exercise=TRUE}
select(flights, ____)
  # YOUR CODE HERE

```

```{r select-hint}
select(flights, ____)

# pass year, month, and day as arguments

```


Select all columns between year and day (inclusive), you can do this using the `:` operator.

```{r select2, exercise=TRUE}
select(flight, ____)

```

```{r select2-hint}
# Use `year:day` inside `select()` to select the range.

```

### Rename a column

Rename the column 'tailnum' to 'tail_num'. 
Use `select()` with a new name for the column on the left-hand side of `=`.
```{r renam, exercise=TRUE}
flights |> 
  # YOUR CODE HERE
```

```{r renam-hint}
# Use `select(new_name = old_name)` to rename columns while selecting.

```



### relocate()

Move the 'time_hour' column to the beginning of the dataset.

```{r reloc, exercise=TRUE}
flights |> 
  # YOUR CODE HERE
```

```{r reloc-hint}
# Use `relocate()` and specify the variable name.

```

  
## Importing data

data import (chapter 7)


## Topic 2

### Exercise with Hint

*Here's an exercise where the chunk is pre-evaluated via the `exercise.eval` option (so the user can see the default output we'd like them to customize). We also add a "hint" to the correct solution via the chunk immediate below labeled `print-limit-hint`.*

Modify the following code to limit the number of rows printed to 5:

```{r print-limit, exercise=TRUE, exercise.eval=TRUE}
mtcars
```

```{r print-limit-hint}
head(mtcars)
```
